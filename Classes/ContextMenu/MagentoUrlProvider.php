<?php

declare(strict_types=1);

namespace WebVision\WvT3unity\ContextMenu;

use TYPO3\CMS\Backend\ContextMenu\ItemProviders\AbstractProvider;
use TYPO3\CMS\Backend\Utility\BackendUtility;
use TYPO3\CMS\Core\Domain\Repository\PageRepository;
use TYPO3\CMS\Core\Exception\SiteNotFoundException;
use TYPO3\CMS\Core\Site\Entity\Site;
use TYPO3\CMS\Core\Site\SiteFinder;
use TYPO3\CMS\Core\Utility\GeneralUtility;
use TYPO3\CMS\Core\Versioning\VersionState;

class MagentoUrlProvider extends AbstractProvider
{
    /**
     * This array contains configuration for items you want to add
     *
     * @var array[]
     */
    protected $itemsConfiguration = [
        'magentoView' => [
            'type' => 'item',
            'label' => 'Show Magento', // you can use "LLL:" syntax here
            'iconIdentifier' => 'actions-view-page',
            'callbackAction' => 'magentoView', //name of the function in the JS file
        ],
    ];

    /**
     * @var array[]
     */
    private array $record;

    protected function initialize(): void
    {
        parent::initialize();
        $this->record = BackendUtility::getRecordWSOL($this->table, (int)$this->identifier) ?? [];
    }

    /**
     * Checks if this provider may be called to provide the list of context menu items for given table.
     *
     * @return bool
     */
    public function canHandle(): bool
    {
        return $this->table === 'pages';
    }

    /**
     * Returns the provider priority which is used for determining the order in which providers are processing items
     * to the result array. Highest priority means provider is evaluated first.
     *
     * This item provider should be called after PageProvider which has priority 100.
     *
     * BEWARE: Returned priority should logically not clash with another provider.
     *         Please check @see \TYPO3\CMS\Backend\ContextMenu\ContextMenu::getAvailableProviders() if needed.
     *
     * @return int
     */
    public function getPriority(): int
    {
        return 55;
    }

    /**
     * Registers the additional JavaScript RequireJS callback-module which will allow to display a notification
     * whenever the user tries to click on the "Hello World" item.
     * The method is called from AbstractProvider::prepareItems() for each context menu item.
     *
     * @param string $itemName
     * @return array
     */
    protected function getAdditionalAttributes(string $itemName): array
    {
        $attribute = [
            'data-callback-module' => '@web-vision/wv_t3unity/context-menu-actions',
        ];
        $magentoUrl = '';
        try {
            $siteFinder = GeneralUtility::makeInstance(SiteFinder::class);
            /** @var Site */
            $site = $siteFinder->getSiteByPageId((int) $this->identifier);
            $magentoUrl =  $site->getConfiguration()['magentoUrl'] ?: null;
        } catch (SiteNotFoundException | \InvalidArgumentException $e) {
        }

        if ($magentoUrl !== '') {
            $url = BackendUtility::getPreviewUrl((int) $this->identifier);

            if ($magentoUrl !== null) {
                $magentoUrl = rtrim((string)$magentoUrl, '/');
                $urlPath = parse_url($url, PHP_URL_PATH);
                $url = $magentoUrl . $urlPath;
            }

            $attribute['data-preview-url'] = htmlspecialchars($url);
        }

        return $attribute;
    }

    /**
     * This method adds custom item to list of items generated by item providers with higher priority value (PageProvider)
     * You could also modify existing items here.
     * The new item is added after the 'info' item.
     *
     * @param array $items
     * @return array
     */
    public function addItems(array $items): array
    {
        $this->initDisabledItems();
        // renders an item based on the configuration from $this->itemsConfiguration
        $localItems = $this->prepareItems($this->itemsConfiguration);

        if (isset($items['view'])) {
            // replace info Item with custom item
            $items['view'] = $localItems['magentoView'];
        } else {
            $items = $items + $localItems;
        }

        //passes array of items to the next item provider
        return $items;
    }

    /**
     * This method is called for each item this provider adds and checks if given item can be added
     *
     * @param string $itemName
     * @param string $type
     * @return bool
     */
    protected function canRender(string $itemName, string $type): bool
    {
        // checking if item is disabled through TSConfig
        if (in_array($itemName, $this->disabledItems, true)) {
            return false;
        }
        $canRender = false;
        switch ($itemName) {
            case 'magentoView':
                $canRender = $this->canMagentoView();
                break;
        }

        return $canRender;
    }

    /**
     * Helper method implementing e.g. access check for certain item
     *
     * @return bool
     */
    protected function canMagentoView(): bool
    {
        return !$this->isRoot()
            && !$this->isDeleted()
            && !$this->isExcludedDoktype();
    }

    protected function isRoot()
    {
        return (int)$this->identifier === 0;
    }

    /**
     * Determines whether this node is deleted.
     */
    protected function isDeleted(): bool
    {
        return !empty($this->record['deleted']) || $this->isDeletePlaceholder();
    }

    /**
     * Returns true if the page doktype is excluded
     */
    protected function isExcludedDoktype(): bool
    {
        $excludeDoktypes = [
            PageRepository::DOKTYPE_RECYCLER,
            PageRepository::DOKTYPE_SYSFOLDER,
            PageRepository::DOKTYPE_SPACER,
        ];

        return in_array((int)($this->record['doktype'] ?? 0), $excludeDoktypes, true);
    }

    /**
     * Returns true is a current record is a delete placeholder
     */
    protected function isDeletePlaceholder(): bool
    {
        if (!isset($this->record['t3ver_state'])) {
            return false;
        }
        return VersionState::cast($this->record['t3ver_state'])->equals(VersionState::DELETE_PLACEHOLDER);
    }
}
